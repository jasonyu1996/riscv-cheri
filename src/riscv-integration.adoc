[#section_rv_integration]
== Integrating Zcheripurecap with the RISC-V Base Integer Instruction Set

{cheri_base_ext_name} is an extension to the RISC-V ISA. The extension adds a
carefully selected set of instructions and CSRs that are sufficient to
implement new security features in the ISA. To ensure compatibility,
{cheri_base_ext_name} also requires some changes to the primary base integer
variants: RV32I, providing 32-bit addresses with 64-bit capabilities, and
RV64I, providing 64-bit addresses with 128-bit capabilities. The remainder of
this chapter describes these changes for both the unprivileged and privileged
components of the base integer RISC-V ISAs.

NOTE: The changes described in this specification also ensure that
{cheri_base_ext_name} is compatible with RV32E.

NOTE: RV128 is not currently supported by any CHERI extension.

=== Memory

A hart supporting {cheri_base_ext_name} has a single byte-addressable address
space of 2^XLEN^ bytes for all memory accesses. Each memory region capable of
holding a capability also stores a tag bit for each naturally aligned CLEN bits
(e.g. 16 bytes in RV64), so that capabilities with their tag set can only be
stored in naturally aligned addresses. Tags must be atomically bound to the
data they protect.

The memory address space is circular, so the byte at address
2^XLEN^ - 1 is adjacent to the byte at address zero. A capability's
<<section_cap_representable_check>> described in xref:section_cap_encoding[xrefstyle=short] is
also circular, so address 0 is within the <<section_cap_representable_check>> of a capability
where address 2^MXLEN^ - 1 is within the bounds.
However, the decoded top field of a capability is MXLEN + 1 bits wide and does *not* wrap, so
a capability with base 2^MXLEN^ - 1 and top 2^MXLEN^ + 1 is not a subset of the
<<infinite-cap>> capability and does not authorise access to the byte at address 0.
Like malformed bounds (see xref:section_cap_malformed[xrefstyle=short]), it is impossible for
a CHERI core to generate a tagged capability with top > 2^MXLEN^.
If such a capability exists then it must have been caused by a logic or memory fault.
Unlike malformed bounds, the top overflowing is not treated as a special case in the
architecture: normal bounds check rules should be followed.

[#section_riscv_programmers_model]
=== Programmer's Model for Zcheripurecap

For {cheri_base_ext_name}, the 32 unprivileged *x* registers of the base
integer ISA are extended so that they are able to hold a capability as well
as renamed to *c* registers. Therefore, each *c* register is CLEN bits wide
and has an out-of-band tag bit. The *x* notation refers to the address field
of the capability in an unprivileged register while the *c* notation is used
to refer to the full capability (i.e. address, metadata and tag) held in the
same unprivileged register.

The tag of the unprivileged *c* registers must be reset to zero. The reset
values of the metadata and address fields are UNSPECIFIED for all unprivileged
*c* registers except *c0*.

Register *c0* is hardwired with all bits, including the capability metadata and
tag, equal to 0. In other words, *c0* is hardwired to the <<null-cap>>
capability.

[#pcc,reftext="pcc"]
==== PCC - The Program Counter Capability

An authorising capability with appropriate permissions is required to execute
instructions in {cheri_base_ext_name}. Therefore, the unprivileged program
counter (*pc*) register is extended so that it is able to hold a capability.
The extended register is called the program counter capability (<<pcc>>). The
<<pcc>> address field is effectively the *pc* in the base RISC-V ISA so that the
hardware automatically increments as instructions are executed. The <<pcc>>'s
metadata and tag are reset to the <<infinite-cap>> capability metadata and tag
with the address field set to the core boot address.

The hardware performs the following checks on <<pcc>> for each instruction
executed in addition to the checks already required by the base RISC-V ISA. A
failing check causes a CHERI exception.

* The tag must be set
* The capability must not be sealed
* The capability must grant execute permission
* All bytes of the instruction must be in bounds

NOTE: Operations that update <<pcc>>, such as changing privilege or executing
jump instructions, unseal capabilities prior to writing. Therefore,
implementations do not need to check that that <<pcc>> is unsealed when
executing each instruction. However, this property has not yet been formally verified and may not hold if additional CHERI extensions beyond {cheri_base_ext_name} are implemented.

NOTE: It is common for implementations to not allow executing *pc* relative
instructions, such as <<AUIPC>> or <<JAL>>, in debug mode.

.Program Counter Capability
[#pcc-format]
include::img/pccreg.edn[]

<<pcc>> is an executable
vector, so it need not be able to hold all possible invalid addresses.

[#section_cap_instructions]
=== Capability Instructions

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* Some instructions from the original CHERI
specification were removed to save encoding space, or because they relate
to features which are not yet in this specification. Instructions were removed
if they do not harm performance and can be emulated using other instructions.
endif::[]

{cheri_base_ext_name} introduces new instructions to the base RISC-V integer
ISA to inspect and operate on capabilities held in registers.

==== Capability Inspection Instructions

These instructions allow software to inspect the fields of a capability held
in a *c* register. The output is an integer value written to an *x* register
representing the decoded field of the capability, such as the permissions or
bounds. These instructions do not cause exceptions.

* <<GCTAG>>: inspects the tag of the input capability. The output is 1 if the
tag is set and 0 otherwise
* <<GCPERM>>: outputs the architectural (AP) and software-defined (SDP)
permission fields of the input capability
* <<GCBASE>>: outputs the expanded base address of the input capability
* <<GCLEN>>: outputs the length of the input capability. Length is defined as
`top - base`. The output is 2^MXLEN^-1 when the capability's length is
2^MXLEN^
* <<CRAM>>: outputs the nearest bounds alignment that a valid capability can
represent
* <<GCHI>>: outputs the compressed capability metadata
* <<SCEQ>>: compares two capabilities including tag, metadata and
address
* <<SCSS>>: tests whether the bounds and permissions of a capability are a
subset of those from another capability

NOTE: <<GCBASE>> and <<GCLEN>> output 0 when a capability with malformed
bounds is provided as an input (see
xref:section_cap_malformed[xrefstyle=short]).

==== Capability Manipulation Instructions

These instructions allow software to manipulate the fields of a capability held
in a *c* register. The output is a capability written to a *c* register with
its fields modified. The output capability has its tag set to 0 if the
input capability did not have a tag set, the output capability has more
permissions or larger bounds compared to the input capability, or the operation
results in a capability with malformed bounds. These instructions do not give
rise to exceptions.

* <<SCADDR>>: set the address of a capability to an arbitrary address
* <<CADD>>, <<CADDI>>: increment the address of the input capability
by an arbitrary offset
* <<SCHI>>: replace a capability's metadata with an arbitrary value. The
output tag is always 0
* <<ACPERM>>: bitwise AND of a mask value with a bit map representation of the
architectural (AP) and software-defined (SDP) permissions fields
* <<SCBNDS>>: set the base and length of a capability. The tag is
cleared, if the encoding cannot represent the bounds exactly
* <<SCBNDSR>>: set the base and length of a capability. The base will be
rounded down and/or the length will be rounded up if the encoding cannot represent
the bounds exactly
* <<SENTRY>>: seal capability as a sentry capability
* <<CBLD>>: replace the base, top, address, permissions and mode fields of a
capability with the fields from another capability
* <<CMV>>: move a capability from a *c* register to another *c* register

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* <<SCBNDS>> and <<SCBNDSI>> perform the role
of the old CSETBOUNDSEXACT while the <<SCBNDSR>> is the old
CSETBOUNDS.
endif::[]

==== Capability Load and Store Instructions

A load capability instruction, <<LC>>, reads CLEN bits from memory together with
its tag and writes the result to a *c* register. The capability authorising the
memory access is provided in a *c* source register, so the effective address is
obtained by incrementing that capability with the sign-extended 12-bit offset.

A store capability instruction, <<SC>>, writes CLEN bits and the tag in a *c* register
to memory. The capability authorising the memory access is provided in a *c*
source register, so the effective address is obtained by incrementing that
capability with the sign-extended 12-bit offset.

<<LC>> and <<SC>> instructions cause CHERI exceptions if the
authorising capability fails any of the following checks:

* The tag is zero
* The capability is sealed
* At least one byte of the memory access is outside the capability's bounds
* For loads, the read permission must be set in AP
* For stores, the write permission must be set in AP

Capability load and store instructions also cause load or store/AMO address
misaligned exceptions if the address is not naturally aligned to a CLEN
boundary.

Misaligned capability loads and stores are errors.  Implementations must
generate exceptions for misaligned capability loads and stores even if they
allow misaligned integer loads and stores to complete normally.  Execution
environments must report misaligned capability loads and stores as errors
and not attempt to emulate them using byte access.  The Zicclsm extension
does not affect capability loads and stores.  Software which uses capability
loads and stores to copy data other than capabilities must ensure that
addresses are aligned.

NOTE: Since there is only one tag per aligned CLEN bit block in memory, it is not
possible to represent a capability value complete with its tag at an
address not aligned to CLEN. Therefore, <<LC>> and <<SC>> give rise to
misaligned address fault exceptions when the effective address to access is
misaligned, even if the implementation supports Zicclsm. To transfer CLEN
misaligned bits without a tag, use integer loads and stores.

For loads, the tag of the capability loaded from memory is cleared if the
authorising capability does not grant permission to read capabilities (i.e.
both <<r_perm>> and <<c_perm>> must be set in AP). For stores, the tag of the
capability written to memory is cleared if the authorising capability does not
grant permission to write capabilities (i.e. both <<w_perm>> and <<c_perm>>
must be set in AP).

WARNING: #TODO: these cases may cause exceptions in the future - we need a way
for software to discover and/or control the behaviour#

[#section_existing_riscv_insns]
=== Existing RISC-V Instructions

The operands or behavior of some instructions in the base RISC-V ISA changes in
{cheri_base_ext_name}.

==== Integer Computational Instructions

Most integer computational instructions operate on XLEN bits of values held in
*x* registers. Therefore, these instructions only operate on the address field
if the input register of the instruction holds a capability. The output is XLEN
bits written to an *x* register; the tag and capability metadata of that
register are zeroed.

The add upper immediate to <<pcc>> instruction (<<AUIPC>>) is used to
build <<pcc>>-relative capabilities. <<AUIPC>> forms a 32-bit offset from the 20-bit
immediate and filling the lowest 12 bits with zeros. The <<pcc>> address is then
incremented by the offset and a representability check is performed so the
capability's tag is cleared if the new address is outside the <<pcc>>'s
<<section_cap_representable_check>>. The resulting CLEN value along with the new tag are
written to a *c* register.

==== Control Transfer Instructions

Control transfer instructions operate as described in the base RISC-V
ISA. They also may cause metadata updates and/or cause exceptions in addition
to the base behaviour as described below.

===== Unconditional Jumps

<<JAL>> sign-extends the offset and adds it to the address of
the jump instruction to form the target address. The target address is
installed in the address field of <<pcc>>. The capability with the address of the
instruction following the jump is sealed and written to a *c* register.

<<JALR>>
allows unconditional, indirect jumps to a target capability. The target capability is
obtained by incrementing the capability in the *c* register operand by the
sign-extended 12-bit offset, then setting the
least significant bit of the result to zero. The target capability is unsealed if it is a sentry with zero offset. The capability
with the address of the instruction following the jump is sealed
and written to a *c* register.

All jumps cause CHERI exceptions when a minimum sized instruction
at the target address is not within the bounds of the <<pcc>>.

<<JALR>> causes a CHERI exception when:

* The target capability's tag is zero
* The target capability is sealed and the immediate is not zero
* A minimum sized instruction at the target capability's address is not
within bounds
* The target capability does not grant execute permission

<<JAL>> and <<JALR>> can also cause instruction address misaligned exceptions
following the standard RISC-V rules.

[#condbr-purecap]
===== Conditional Branches

Branch instructions (see xref:insns-conbr-32bit[xrefstyle=short]) encode signed
offsets in multiples of 2 bytes. The offset is sign-extended and added to the
address of the branch instruction to form the target address.

Branch instructions compare two *x* registers as described in the base RISC-V
ISA, so the metadata and tag values are disregarded in the comparison if the
operand registers hold capabilities. If the comparison evaluates to true, then
the target address is installed in the <<pcc>>'s address field. These instructions cause CHERI exceptions
when a minimum sized instruction at the target address is not within the
<<pcc>>'s bounds.

==== Integer Load and Store Instructions

Integer load and store instructions transfer the amount of integer data described in
the base RISC-V ISA between the registers and memory. For example, <<LD>> and
<<LW>> load 64-bit and 32-bit values respectively from memory into an *x*
register.  However, the address operands for load and store instructions are
interpreted differently in {cheri_base_ext_name}: the capability authorising
the access is in the *c* register operand and the memory address is given by
incrementing the address of that capability by the sign-extended 12-bit
immediate offset.

All load and store instructions cause CHERI exceptions if the
authorising capability fails any of the following checks:

* The tag is set
* The capability is unsealed
* All bytes of accessed memory are inside the capability's bounds
* For loads, the read permission must be set in AP
* For stores, the write permission must be set in AP

Integer load instructions always zero the tag and metadata of the result register.

Integer stores write zero to the tag associated with the memory locations that
are naturally aligned to CLEN. Therefore, misaligned stores may clear up to
two tag bits in memory.
